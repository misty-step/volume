/**
 * CHANGELOG.md Parser
 *
 * Parses Keep a Changelog format generated by release-please.
 * Extracts structured release data for display and LLM processing.
 */

import { readFileSync } from "fs";
import type { Release, ChangelogEntry, ChangeType } from "./types";

/** Map section headers to change types */
const SECTION_TO_TYPE: Record<string, ChangeType> = {
  Features: "feat",
  "Bug Fixes": "fix",
  "Performance Improvements": "perf",
  Refactoring: "refactor",
  Documentation: "docs",
  Maintenance: "chore",
  Styling: "style",
  Testing: "test",
};

/**
 * Parse a single changelog entry line.
 *
 * Format: `* **scope:** description ([#123](url)) ([abc1234](url))`
 * Or:     `* description ([#123](url)) ([abc1234](url))`
 */
function parseEntry(line: string, type: ChangeType): ChangelogEntry | null {
  // Remove leading "* "
  const content = line.replace(/^\*\s*/, "").trim();
  if (!content) return null;

  // Extract scope if present: **scope:**
  const scopeMatch = content.match(/^\*\*([^*]+)\*\*:\s*/);
  const scope = scopeMatch ? scopeMatch[1] : undefined;
  const withoutScope = scopeMatch ? content.slice(scopeMatch[0].length) : content;

  // Extract PR number: ([#123](url))
  const prMatch = withoutScope.match(/\(\[#(\d+)\]\([^)]+\)\)/);
  const pr = prMatch ? parseInt(prMatch[1]!, 10) : undefined;

  // Extract commit SHA: ([abc1234](url))
  const commitMatch = withoutScope.match(/\(\[([a-f0-9]{7,})\]\([^)]+\)\)/);
  const commit = commitMatch ? commitMatch[1] : undefined;

  // Extract description (everything before the links)
  let description = withoutScope
    .replace(/\s*\(\[#\d+\]\([^)]+\)\)/g, "") // Remove PR links
    .replace(/\s*\(\[[a-f0-9]+\]\([^)]+\)\)/g, "") // Remove commit links
    .trim();

  // Check for breaking change marker
  const breaking = description.includes("BREAKING CHANGE") || description.startsWith("!");
  if (breaking) {
    description = description.replace(/^!\s*/, "").replace(/BREAKING CHANGE:\s*/i, "");
  }

  return {
    type,
    scope,
    description,
    pr,
    commit,
    breaking,
  };
}

/**
 * Parse the entire CHANGELOG.md file into structured releases.
 */
export function parseChangelog(changelogPath: string): Release[] {
  const content = readFileSync(changelogPath, "utf-8");
  const lines = content.split("\n");

  const releases: Release[] = [];
  let currentRelease: Release | null = null;
  let currentType: ChangeType | null = null;

  for (const line of lines) {
    // Version header: ## [1.6.0](url) (2026-01-19)
    const versionMatch = line.match(
      /^## \[(\d+\.\d+\.\d+)\]\((https?:\/\/[^)]+)\)\s*\((\d{4}-\d{2}-\d{2})\)/
    );
    if (versionMatch) {
      if (currentRelease) {
        releases.push(currentRelease);
      }
      currentRelease = {
        version: versionMatch[1]!,
        compareUrl: versionMatch[2]!,
        date: versionMatch[3]!,
        changes: [],
      };
      currentType = null;
      continue;
    }

    // Version header without URL: ## 1.0.0 (2026-01-02)
    const versionMatchSimple = line.match(/^## (\d+\.\d+\.\d+)\s*\((\d{4}-\d{2}-\d{2})\)/);
    if (versionMatchSimple) {
      if (currentRelease) {
        releases.push(currentRelease);
      }
      currentRelease = {
        version: versionMatchSimple[1]!,
        date: versionMatchSimple[2]!,
        changes: [],
      };
      currentType = null;
      continue;
    }

    // Section header: ### Features
    const sectionMatch = line.match(/^### (.+)$/);
    if (sectionMatch && currentRelease) {
      const sectionName = sectionMatch[1]!.trim();
      currentType = SECTION_TO_TYPE[sectionName] || null;
      continue;
    }

    // Entry line: * description
    if (line.startsWith("* ") && currentRelease && currentType) {
      const entry = parseEntry(line, currentType);
      if (entry) {
        currentRelease.changes.push(entry);
      }
    }
  }

  // Don't forget the last release
  if (currentRelease) {
    releases.push(currentRelease);
  }

  return releases;
}

/**
 * Get a single release by version.
 */
export function getReleaseByVersion(
  releases: Release[],
  version: string
): Release | undefined {
  // Normalize version (remove leading 'v' if present)
  const normalized = version.replace(/^v/, "");
  return releases.find((r) => r.version === normalized);
}

/**
 * Format a release as markdown for technical changelog display.
 */
export function formatReleaseMarkdown(release: Release): string {
  const lines: string[] = [];

  // Group changes by type
  const byType = new Map<ChangeType, ChangelogEntry[]>();
  for (const change of release.changes) {
    const existing = byType.get(change.type) || [];
    existing.push(change);
    byType.set(change.type, existing);
  }

  // Output in standard order
  const typeOrder: ChangeType[] = ["feat", "fix", "perf", "refactor", "docs", "chore"];
  const typeLabels: Record<ChangeType, string> = {
    feat: "Features",
    fix: "Bug Fixes",
    perf: "Performance",
    refactor: "Refactoring",
    docs: "Documentation",
    chore: "Maintenance",
    style: "Styling",
    test: "Testing",
  };

  for (const type of typeOrder) {
    const changes = byType.get(type);
    if (!changes?.length) continue;

    lines.push(`### ${typeLabels[type]}`);
    lines.push("");
    for (const change of changes) {
      const scope = change.scope ? `**${change.scope}:** ` : "";
      const breaking = change.breaking ? "⚠️ " : "";
      lines.push(`- ${breaking}${scope}${change.description}`);
    }
    lines.push("");
  }

  return lines.join("\n");
}
