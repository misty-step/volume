import { defineSchema, defineTable } from "convex/server";
import { v, Validator } from "convex/values";
import { GOAL_TYPES, type GoalType } from "@/lib/goals";

// Derive validator from GOAL_TYPES constant (single source of truth)
// Type assertion needed because v.union loses literal inference with spread
const goalValidator = v.union(
  ...(GOAL_TYPES.map((g) => v.literal(g)) as unknown as [
    Validator<GoalType>,
    ...Validator<GoalType>[],
  ])
) as unknown as Validator<GoalType>;

export default defineSchema({
  exercises: defineTable({
    userId: v.string(),
    name: v.string(),
    /**
     * AI-classified muscle groups (e.g., ["Chest", "Triceps"])
     * Generated by GPT-5-nano on exercise creation, user-editable
     * Optional for backwards compatibility with existing exercises
     */
    muscleGroups: v.optional(v.array(v.string())),
    createdAt: v.number(),
    /**
     * Soft delete timestamp (Unix ms). When set, exercise is "deleted" but preserved
     * for history display. Use deleteExercise mutation (not ctx.db.delete) to maintain
     * data integrity. See convex/exercises.ts for auto-restore logic.
     */
    deletedAt: v.optional(v.number()),
  })
    .index("by_user", ["userId"])
    .index("by_user_name", ["userId", "name"])
    // Index for efficient active-only queries (deletedAt === undefined)
    .index("by_user_deleted", ["userId", "deletedAt"]),

  sets: defineTable({
    userId: v.string(),
    exerciseId: v.id("exercises"),
    reps: v.optional(v.number()), // Required for rep-based exercises, optional for duration-based
    weight: v.optional(v.number()),
    unit: v.optional(v.string()), // "lbs" or "kg" - stored with each set for data integrity
    duration: v.optional(v.number()), // Duration in seconds for time-based exercises
    performedAt: v.number(), // Unix timestamp
  })
    .index("by_user", ["userId"])
    .index("by_exercise", ["exerciseId", "performedAt"])
    .index("by_user_performed", ["userId", "performedAt"]),

  users: defineTable({
    clerkUserId: v.string(),
    timezone: v.optional(v.string()), // IANA timezone (e.g., "America/New_York")
    dailyReportsEnabled: v.optional(v.boolean()), // Default: false (opt-in)
    weeklyReportsEnabled: v.optional(v.boolean()), // Default: true
    monthlyReportsEnabled: v.optional(v.boolean()), // Default: false
    preferences: v.optional(
      v.object({
        goals: v.optional(v.array(goalValidator)),
        customGoal: v.optional(v.string()),
        trainingSplit: v.optional(v.string()),
        coachNotes: v.optional(v.string()),
      })
    ),
    onboardingDismissedAt: v.optional(v.number()),
    // Subscription fields
    trialEndsAt: v.optional(v.number()), // Unix timestamp when trial expires
    stripeCustomerId: v.optional(v.string()), // Stripe customer ID
    stripeSubscriptionId: v.optional(v.string()), // Active subscription ID
    subscriptionStatus: v.optional(
      v.union(
        v.literal("trial"),
        v.literal("active"),
        v.literal("past_due"),
        v.literal("canceled"),
        v.literal("expired")
      )
    ),
    subscriptionPeriodEnd: v.optional(v.number()), // Current period end timestamp
    // Webhook idempotency: prevent duplicate/stale event processing
    lastStripeEventId: v.optional(v.string()),
    lastStripeEventTimestamp: v.optional(v.number()),
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_clerk_id", ["clerkUserId"])
    .index("by_daily_enabled", ["dailyReportsEnabled"])
    .index("by_timezone", ["timezone"])
    .index("by_stripe_customer", ["stripeCustomerId"]),

  aiReports: defineTable({
    userId: v.string(),
    reportType: v.optional(
      v.union(v.literal("daily"), v.literal("weekly"), v.literal("monthly"))
    ), // Report type (optional for backward compatibility, defaults to "weekly")
    weekStartDate: v.number(), // Unix timestamp for Monday 00:00
    generatedAt: v.number(), // Unix timestamp of generation
    content: v.optional(v.string()), // V1: Markdown-formatted AI response (optional for v2)
    /**
     * V2: Structured JSON content for visual rendering
     * Contains computed metrics, PR data, and AI-generated creative content.
     * When present, frontend renders structured components instead of markdown.
     */
    structuredContent: v.optional(v.any()),
    /**
     * Report version for renderer selection
     * - undefined or "1.0": Legacy markdown (uses content field)
     * - "2.0": Structured JSON (uses structuredContent field)
     */
    reportVersion: v.optional(v.string()),
    metricsSnapshot: v.object({
      volume: v.array(
        v.object({
          exerciseName: v.string(),
          totalVolume: v.number(),
          sets: v.number(),
          isBodyweight: v.optional(v.boolean()), // Optional for backward compatibility
        })
      ),
      prs: v.array(
        v.object({
          exerciseName: v.string(),
          prType: v.string(),
          improvement: v.number(),
          performedAt: v.number(),
        })
      ),
      streak: v.object({
        currentStreak: v.number(),
        longestStreak: v.number(),
        totalWorkouts: v.number(),
      }),
      frequency: v.object({
        workoutDays: v.number(),
        restDays: v.number(),
        avgSetsPerDay: v.number(),
      }),
    }),
    model: v.string(), // e.g., "gpt-5-mini"
    tokenUsage: v.object({
      input: v.number(),
      output: v.number(),
      costUSD: v.number(),
    }),
  })
    .index("by_user", ["userId"])
    .index("by_user_week", ["userId", "weekStartDate"])
    .index("by_user_type_date", ["userId", "reportType", "weekStartDate"]),

  rateLimits: defineTable({
    userId: v.string(),
    scope: v.string(),
    windowStartMs: v.number(),
    windowMs: v.number(),
    count: v.number(),
    expiresAt: v.number(),
  })
    .index("by_user_scope_window", ["userId", "scope", "windowStartMs"])
    .index("by_expires", ["expiresAt"]),

  /**
   * Pre-aggregated platform statistics cache for landing page social proof.
   * Updated daily via cron job to avoid full table scans on every page load.
   * Single document table - only one row should exist.
   */
  platformStatsCache: defineTable({
    totalSets: v.number(),
    totalLifters: v.number(),
    setsThisWeek: v.number(),
    computedAt: v.number(), // Unix timestamp of last computation
  }),
});
